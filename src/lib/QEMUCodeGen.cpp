#include "QEMUCodeGen.h"
#include "llvm/Support/Format.h"
#include <cctype>

namespace qemu_codegen {

//===----------------------------------------------------------------------===//
// SignalInfo 实现
//===----------------------------------------------------------------------===//

SignalInfo::SignalInfo(llvm::StringRef n, int w)
    : name(n.str()), bitWidth(w), type(QEMUSignalType::SIMPLE_REG),
      direction(CounterDirection::UP), stepValue(1) {}

//===----------------------------------------------------------------------===//
// QEMUDeviceGenerator 实现
//===----------------------------------------------------------------------===//

QEMUDeviceGenerator::QEMUDeviceGenerator(llvm::StringRef deviceName)
    : deviceName_(deviceName.str()) {}

void QEMUDeviceGenerator::addSimpleReg(llvm::StringRef name, int bitWidth) {
  SignalInfo sig(name, bitWidth);
  sig.type = QEMUSignalType::SIMPLE_REG;
  signals_.push_back(sig);
}

void QEMUDeviceGenerator::addICountCounter(llvm::StringRef name, int bitWidth,
                                            CounterDirection dir, int step) {
  SignalInfo sig(name, bitWidth);
  sig.type = QEMUSignalType::ICOUNT_COUNTER;
  sig.direction = dir;
  sig.stepValue = step;
  signals_.push_back(sig);
}

void QEMUDeviceGenerator::addEventHandler(const clk_analysis::EventHandler &handler) {
  eventHandlers_.push_back(handler);
}

void QEMUDeviceGenerator::addInputSignal(llvm::StringRef name, int bitWidth) {
  inputSignals_.emplace_back(name.str(), bitWidth);
}

void QEMUDeviceGenerator::addDerivedSignal(const clk_analysis::DerivedSignal &derived) {
  derivedSignals_.push_back(derived);
}

void QEMUDeviceGenerator::addControlRelation(const clk_analysis::ControlRelation &relation) {
  controlRelations_.push_back(relation);
}

void QEMUDeviceGenerator::generateHeader(llvm::raw_ostream &os) {
  std::string upperName = toUpperCase(deviceName_);

  os << "/*\n";
  os << " * Auto-generated QEMU device: " << deviceName_ << "\n";
  os << " * Generated by LLHD-to-QEMU converter\n";
  os << " *\n";
  os << " * Uses ptimer + QEMU_CLOCK_VIRTUAL for counter implementation.\n";
  os << " * Compatible with both icount mode and real-time mode.\n";
  os << " */\n\n";

  os << "#ifndef HW_" << upperName << "_H\n";
  os << "#define HW_" << upperName << "_H\n\n";

  os << "#include \"hw/sysbus.h\"\n";
  os << "#include \"hw/ptimer.h\"\n";
  os << "#include \"qom/object.h\"\n";
  os << "#include \"qemu/timer.h\"\n\n";

  // 设备类型定义
  os << "#define TYPE_" << upperName << " \"" << deviceName_ << "\"\n";
  os << "OBJECT_DECLARE_SIMPLE_TYPE(" << deviceName_ << "_state, "
     << upperName << ")\n\n";

  // 设备状态结构体
  os << "typedef struct " << deviceName_ << "_state {\n";
  os << "    SysBusDevice parent_obj;\n";
  os << "    MemoryRegion iomem;\n";
  os << "    qemu_irq irq;\n\n";

  // 生成寄存器字段
  for (const auto &sig : signals_) {
    std::string safeName = sanitizeName(sig.name);
    if (sig.type == QEMUSignalType::ICOUNT_COUNTER) {
      os << "    /* ptimer-based counter: " << sig.name << " */\n";
      os << "    ptimer_state *" << safeName << "_ptimer;\n";
      os << "    " << getCType(sig.bitWidth) << " " << safeName << "_limit;  "
         << "/* 计数上限/reload值 */\n";
    } else {
      os << "    " << getCType(sig.bitWidth) << " " << safeName << ";\n";
    }
  }

  // 生成输入信号字段（用于存储和比较）
  for (const auto &input : inputSignals_) {
    // 跳过已经在 signals_ 中的
    bool found = false;
    for (const auto &sig : signals_) {
      if (sig.name == input.first) {
        found = true;
        break;
      }
    }
    if (!found) {
      std::string safeName = sanitizeName(input.first);
      os << "    " << getCType(input.second) << " " << safeName << ";  /* input */\n";
    }
  }

  os << "} " << deviceName_ << "_state;\n\n";
  os << "#endif /* HW_" << upperName << "_H */\n";
}

void QEMUDeviceGenerator::generateSource(llvm::raw_ostream &os) {
  std::string upperName = toUpperCase(deviceName_);

  os << "/*\n";
  os << " * Auto-generated QEMU device: " << deviceName_ << "\n";
  os << " *\n";
  os << " * Uses ptimer with QEMU_CLOCK_VIRTUAL.\n";
  os << " * - In icount mode: virtual clock driven by instruction counter\n";
  os << " * - In real-time mode: virtual clock driven by host timer\n";
  os << " */\n\n";

  os << "#include \"qemu/osdep.h\"\n";
  os << "#include \"hw/irq.h\"\n";
  os << "#include \"hw/qdev-properties.h\"\n";
  os << "#include \"qemu/log.h\"\n";
  os << "#include \"qemu/module.h\"\n";
  os << "#include \"" << deviceName_ << ".h\"\n\n";

  // 生成 ptimer 回调和辅助函数
  generatePtimerCallback(os);

  // 生成 ptimer 计数器的读取/写入函数
  for (const auto &sig : signals_) {
    if (sig.type == QEMUSignalType::ICOUNT_COUNTER) {
      generatePtimerRead(os, sig);
      generatePtimerWrite(os, sig);
    }
  }

  // 生成派生信号的 getter 函数
  generateDerivedSignalGetters(os);

  // 生成事件处理函数
  generateEventHandlers(os);

  generateMMIORead(os);
  generateMMIOWrite(os);
  generateDeviceInit(os);
}

//===----------------------------------------------------------------------===//
// ptimer 回调和辅助函数
//===----------------------------------------------------------------------===//

void QEMUDeviceGenerator::generatePtimerCallback(llvm::raw_ostream &os) {
  os << "/*\n";
  os << " * ptimer 到期回调 - 计数器归零时触发\n";
  os << " */\n";
  os << "static void " << deviceName_ << "_timer_tick(void *opaque)\n";
  os << "{\n";
  os << "    " << deviceName_ << "_state *s = opaque;\n";
  os << "    /* 触发中断 */\n";
  os << "    qemu_irq_raise(s->irq);\n";
  os << "}\n\n";
}

void QEMUDeviceGenerator::generatePtimerRead(llvm::raw_ostream &os,
                                              const SignalInfo &sig) {
  std::string safeName = sanitizeName(sig.name);
  os << "/*\n";
  os << " * 读取 " << sig.name << " 计数器\n";
  os << " * 使用 ptimer 获取当前值\n";
  os << " */\n";
  os << "static " << getCType(sig.bitWidth) << " "
     << deviceName_ << "_get_" << safeName
     << "(" << deviceName_ << "_state *s)\n";
  os << "{\n";
  os << "    return ptimer_get_count(s->" << safeName << "_ptimer);\n";
  os << "}\n\n";
}

void QEMUDeviceGenerator::generatePtimerWrite(llvm::raw_ostream &os,
                                               const SignalInfo &sig) {
  std::string safeName = sanitizeName(sig.name);
  os << "/*\n";
  os << " * 写入 " << sig.name << " 计数器（加载新值）\n";
  os << " */\n";
  os << "static void " << deviceName_ << "_set_" << safeName
     << "(" << deviceName_ << "_state *s, " << getCType(sig.bitWidth) << " value)\n";
  os << "{\n";
  os << "    ptimer_transaction_begin(s->" << safeName << "_ptimer);\n";
  os << "    ptimer_set_count(s->" << safeName << "_ptimer, value);\n";
  os << "    ptimer_transaction_commit(s->" << safeName << "_ptimer);\n";
  os << "}\n\n";

  os << "/*\n";
  os << " * 设置 " << sig.name << " 计数器上限/reload值\n";
  os << " */\n";
  os << "static void " << deviceName_ << "_set_" << safeName << "_limit"
     << "(" << deviceName_ << "_state *s, " << getCType(sig.bitWidth) << " limit)\n";
  os << "{\n";
  os << "    s->" << safeName << "_limit = limit;\n";
  os << "    ptimer_transaction_begin(s->" << safeName << "_ptimer);\n";
  os << "    ptimer_set_limit(s->" << safeName << "_ptimer, limit, 1);\n";
  os << "    ptimer_transaction_commit(s->" << safeName << "_ptimer);\n";
  os << "}\n\n";

  os << "/*\n";
  os << " * 启动 " << sig.name << " 计数器\n";
  os << " */\n";
  os << "static void " << deviceName_ << "_start_" << safeName
     << "(" << deviceName_ << "_state *s)\n";
  os << "{\n";
  os << "    ptimer_transaction_begin(s->" << safeName << "_ptimer);\n";
  os << "    ptimer_run(s->" << safeName << "_ptimer, 0);  /* 0 = 周期模式 */\n";
  os << "    ptimer_transaction_commit(s->" << safeName << "_ptimer);\n";
  os << "}\n\n";

  os << "/*\n";
  os << " * 停止 " << sig.name << " 计数器\n";
  os << " */\n";
  os << "static void " << deviceName_ << "_stop_" << safeName
     << "(" << deviceName_ << "_state *s)\n";
  os << "{\n";
  os << "    ptimer_transaction_begin(s->" << safeName << "_ptimer);\n";
  os << "    ptimer_stop(s->" << safeName << "_ptimer);\n";
  os << "    ptimer_transaction_commit(s->" << safeName << "_ptimer);\n";
  os << "}\n\n";
}

void QEMUDeviceGenerator::generateDerivedSignalGetters(llvm::raw_ostream &os) {
  for (const auto &derived : derivedSignals_) {
    std::string safeName = sanitizeName(derived.name);
    os << "/*\n";
    os << " * 获取派生信号 " << derived.name << "\n";
    os << " * 计算: " << derived.sourceSignal;
    switch (derived.exprType) {
      case clk_analysis::DerivedExprType::SHIFT_RIGHT:
        os << " >> " << derived.exprValue;
        break;
      case clk_analysis::DerivedExprType::SHIFT_LEFT:
        os << " << " << derived.exprValue;
        break;
      case clk_analysis::DerivedExprType::DIVIDE:
        os << " / " << derived.exprValue;
        break;
      case clk_analysis::DerivedExprType::MULTIPLY:
        os << " * " << derived.exprValue;
        break;
      default:
        break;
    }
    os << "\n */\n";

    os << "static " << getCType(derived.bitWidth) << " "
       << deviceName_ << "_get_" << safeName
       << "(" << deviceName_ << "_state *s)\n";
    os << "{\n";
    os << "    return ";

    // 获取源信号的读取表达式
    std::string sourceExpr = getSignalReadExpr(derived.sourceSignal);

    switch (derived.exprType) {
      case clk_analysis::DerivedExprType::SHIFT_RIGHT:
        os << sourceExpr << " >> " << derived.exprValue;
        break;
      case clk_analysis::DerivedExprType::SHIFT_LEFT:
        os << sourceExpr << " << " << derived.exprValue;
        break;
      case clk_analysis::DerivedExprType::DIVIDE:
        os << sourceExpr << " / " << derived.exprValue;
        break;
      case clk_analysis::DerivedExprType::MULTIPLY:
        os << sourceExpr << " * " << derived.exprValue;
        break;
      default:
        os << sourceExpr;
    }

    os << ";\n}\n\n";
  }
}

void QEMUDeviceGenerator::generateMMIORead(llvm::raw_ostream &os) {
  os << "static uint64_t " << deviceName_ << "_read(void *opaque, hwaddr addr, unsigned size)\n";
  os << "{\n";
  os << "    " << deviceName_ << "_state *s = opaque;\n";
  os << "    uint64_t value = 0;\n\n";
  os << "    switch (addr) {\n";

  int offset = 0;
  for (const auto &sig : signals_) {
    std::string safeName = sanitizeName(sig.name);
    os << "    case 0x" << llvm::format_hex_no_prefix(offset, 2) << ":  /* " << sig.name << " */\n";
    if (sig.type == QEMUSignalType::ICOUNT_COUNTER) {
      os << "        value = " << deviceName_ << "_get_" << safeName << "(s);\n";
    } else {
      os << "        value = s->" << safeName << ";\n";
    }
    os << "        break;\n";
    offset += (sig.bitWidth + 7) / 8;
    if (offset % 4 != 0) offset = (offset + 3) & ~3;
  }

  os << "    default:\n";
  os << "        qemu_log_mask(LOG_GUEST_ERROR, \"" << deviceName_
     << ": bad read at 0x%\" HWADDR_PRIx \"\\n\", addr);\n";
  os << "    }\n";
  os << "    return value;\n";
  os << "}\n\n";
}

void QEMUDeviceGenerator::generateMMIOWrite(llvm::raw_ostream &os) {
  os << "static void " << deviceName_ << "_write(void *opaque, hwaddr addr,\n";
  os << "                              uint64_t value, unsigned size)\n";
  os << "{\n";
  os << "    " << deviceName_ << "_state *s = opaque;\n\n";
  os << "    switch (addr) {\n";

  int offset = 0;
  for (const auto &sig : signals_) {
    std::string safeName = sanitizeName(sig.name);
    os << "    case 0x" << llvm::format_hex_no_prefix(offset, 2) << ":  /* " << sig.name << " */\n";
    if (sig.type == QEMUSignalType::ICOUNT_COUNTER) {
      os << "        " << deviceName_ << "_set_" << safeName << "(s, value);\n";
    } else {
      os << "        s->" << safeName << " = value;\n";
    }

    // 检查是否有对应的事件处理器
    for (const auto &handler : eventHandlers_) {
      if (handler.triggerSignal == sig.name) {
        os << "        " << deviceName_ << "_on_" << sanitizeName(sig.name) << "_write(s, value);\n";
        break;
      }
    }

    os << "        break;\n";
    offset += (sig.bitWidth + 7) / 8;
    if (offset % 4 != 0) offset = (offset + 3) & ~3;
  }

  // 为输入信号生成 MMIO 入口（如果它们不在 signals_ 中）
  for (const auto &input : inputSignals_) {
    bool found = false;
    for (const auto &sig : signals_) {
      if (sig.name == input.first) {
        found = true;
        break;
      }
    }
    if (!found) {
      std::string safeName = sanitizeName(input.first);
      os << "    case 0x" << llvm::format_hex_no_prefix(offset, 2) << ":  /* " << input.first << " (input) */\n";
      // 存储输入信号值
      os << "        s->" << safeName << " = value;\n";
      // 检查是否有对应的事件处理器
      for (const auto &handler : eventHandlers_) {
        if (handler.triggerSignal == input.first) {
          os << "        " << deviceName_ << "_on_" << safeName << "_write(s, value);\n";
          break;
        }
      }
      os << "        break;\n";
      offset += 4;
    }
  }

  os << "    default:\n";
  os << "        qemu_log_mask(LOG_GUEST_ERROR, \"" << deviceName_
     << ": bad write at 0x%\" HWADDR_PRIx \"\\n\", addr);\n";
  os << "    }\n";
  os << "}\n\n";
}

void QEMUDeviceGenerator::generateDeviceInit(llvm::raw_ostream &os) {
  std::string upperName = toUpperCase(deviceName_);

  os << "static const MemoryRegionOps " << deviceName_ << "_ops = {\n";
  os << "    .read = " << deviceName_ << "_read,\n";
  os << "    .write = " << deviceName_ << "_write,\n";
  os << "    .endianness = DEVICE_LITTLE_ENDIAN,\n";
  os << "};\n\n";

  os << "static void " << deviceName_ << "_init(Object *obj)\n";
  os << "{\n";
  os << "    " << deviceName_ << "_state *s = " << upperName << "(obj);\n";
  os << "    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);\n\n";

  os << "    memory_region_init_io(&s->iomem, obj, &" << deviceName_ << "_ops, s,\n";
  os << "                          TYPE_" << upperName << ", 0x1000);\n";
  os << "    sysbus_init_mmio(sbd, &s->iomem);\n";
  os << "    sysbus_init_irq(sbd, &s->irq);\n";
  os << "}\n\n";

  // realize 函数 - 初始化 ptimer
  os << "static void " << deviceName_ << "_realize(DeviceState *dev, Error **errp)\n";
  os << "{\n";
  os << "    " << deviceName_ << "_state *s = " << upperName << "(dev);\n\n";

  // 为每个计数器创建 ptimer
  for (const auto &sig : signals_) {
    if (sig.type == QEMUSignalType::ICOUNT_COUNTER) {
      std::string safeName = sanitizeName(sig.name);
      os << "    /*\n";
      os << "     * 创建 ptimer: " << sig.name << "\n";
      os << "     * 使用 QEMU_CLOCK_VIRTUAL - 在 icount 模式下用 instruction counter\n";
      os << "     *                          在普通模式下用 host timer\n";
      os << "     */\n";
      os << "    s->" << safeName << "_ptimer = ptimer_init(" << deviceName_ << "_timer_tick, s,\n";
      os << "                                                PTIMER_POLICY_DEFAULT);\n";
      os << "    ptimer_transaction_begin(s->" << safeName << "_ptimer);\n";
      os << "    /* 设置频率 (每秒多少次) - 根据 HDL 时钟频率调整 */\n";
      os << "    ptimer_set_freq(s->" << safeName << "_ptimer, 1000000);  /* 1MHz */\n";
      os << "    ptimer_transaction_commit(s->" << safeName << "_ptimer);\n\n";
    }
  }
  os << "}\n\n";

  os << "static void " << deviceName_ << "_reset(DeviceState *dev)\n";
  os << "{\n";
  os << "    " << deviceName_ << "_state *s = " << upperName << "(dev);\n\n";
  for (const auto &sig : signals_) {
    std::string safeName = sanitizeName(sig.name);
    if (sig.type == QEMUSignalType::ICOUNT_COUNTER) {
      os << "    /* 重置 ptimer: " << sig.name << " */\n";
      os << "    ptimer_transaction_begin(s->" << safeName << "_ptimer);\n";
      os << "    ptimer_stop(s->" << safeName << "_ptimer);\n";
      os << "    ptimer_set_count(s->" << safeName << "_ptimer, 0);\n";
      os << "    ptimer_transaction_commit(s->" << safeName << "_ptimer);\n";
      os << "    s->" << safeName << "_limit = 0;\n";
    } else {
      os << "    s->" << safeName << " = 0;\n";
    }
  }
  os << "    qemu_irq_lower(s->irq);\n";
  os << "}\n\n";

  os << "static void " << deviceName_ << "_class_init(ObjectClass *oc, void *data)\n";
  os << "{\n";
  os << "    DeviceClass *dc = DEVICE_CLASS(oc);\n";
  os << "    dc->realize = " << deviceName_ << "_realize;\n";
  os << "    dc->reset = " << deviceName_ << "_reset;\n";
  os << "}\n\n";

  os << "static const TypeInfo " << deviceName_ << "_info = {\n";
  os << "    .name = TYPE_" << upperName << ",\n";
  os << "    .parent = TYPE_SYS_BUS_DEVICE,\n";
  os << "    .instance_size = sizeof(" << deviceName_ << "_state),\n";
  os << "    .instance_init = " << deviceName_ << "_init,\n";
  os << "    .class_init = " << deviceName_ << "_class_init,\n";
  os << "};\n\n";

  os << "static void " << deviceName_ << "_register_types(void)\n";
  os << "{\n";
  os << "    type_register_static(&" << deviceName_ << "_info);\n";
  os << "}\n\n";
  os << "type_init(" << deviceName_ << "_register_types)\n";
}

//===----------------------------------------------------------------------===//
// 事件处理函数生成
//===----------------------------------------------------------------------===//

void QEMUDeviceGenerator::indent(llvm::raw_ostream &os, int level) {
  for (int i = 0; i < level; ++i) {
    os << "    ";
  }
}

void QEMUDeviceGenerator::generateEventHandlers(llvm::raw_ostream &os) {
  if (eventHandlers_.empty()) return;

  os << "/*\n";
  os << " * Event Handlers - triggered by input signal writes\n";
  os << " */\n\n";

  for (const auto &handler : eventHandlers_) {
    generateEventHandler(os, handler);
  }
}

void QEMUDeviceGenerator::generateEventHandler(llvm::raw_ostream &os,
                                                const clk_analysis::EventHandler &handler) {
  using namespace clk_analysis;

  std::string safeTrigger = sanitizeName(handler.triggerSignal);

  os << "/*\n";
  os << " * Handler for " << handler.triggerSignal << " signal changes\n";

  // 检查这个信号是否是控制信号
  auto countersActiveHigh = getControlledCounters(handler.triggerSignal, true);
  auto countersActiveLow = getControlledCounters(handler.triggerSignal, false);

  if (!countersActiveHigh.empty() || !countersActiveLow.empty()) {
    os << " * Controls ptimer:";
    for (const auto &c : countersActiveHigh) {
      os << " " << c << "(active-high)";
    }
    for (const auto &c : countersActiveLow) {
      os << " " << c << "(active-low)";
    }
    os << "\n";
  }
  os << " */\n";

  os << "static void " << deviceName_ << "_on_" << safeTrigger
     << "_write(" << deviceName_ << "_state *s, uint32_t value)\n";
  os << "{\n";

  // 如果是控制信号，直接生成简化的 if-else 结构
  if (!countersActiveHigh.empty() || !countersActiveLow.empty()) {
    os << "    if (value) {\n";

    // active-high: value=1 时启动
    for (const auto &counter : countersActiveHigh) {
      generatePtimerStartStop(os, counter, true, 2);
    }
    // active-low: value=1 时停止
    for (const auto &counter : countersActiveLow) {
      generatePtimerStartStop(os, counter, false, 2);
    }

    // 生成 true 分支中的其他动作（非 ptimer 控制的）
    for (const auto &branch : handler.branches) {
      if (branch.condType == ConditionType::SIGNAL_TRUE) {
        for (const auto &action : branch.actions) {
          // 跳过 ACCUMULATE（由 ptimer 处理）
          if (action.type != ActionType::ACCUMULATE) {
            generateActionCode(os, action, 2);
          }
        }
        // 生成嵌套条件（父条件是 SIGNAL_TRUE）
        for (const auto &nested : branch.nestedBranches) {
          generateConditionCode(os, nested, 2, ConditionType::SIGNAL_TRUE);
        }
      }
    }

    os << "    } else {\n";

    // active-high: value=0 时停止
    for (const auto &counter : countersActiveHigh) {
      generatePtimerStartStop(os, counter, false, 2);
    }
    // active-low: value=0 时启动
    for (const auto &counter : countersActiveLow) {
      generatePtimerStartStop(os, counter, true, 2);
    }

    // 生成 false 分支中的其他动作
    for (const auto &branch : handler.branches) {
      if (branch.condType == ConditionType::SIGNAL_FALSE) {
        for (const auto &action : branch.actions) {
          if (action.type != ActionType::ACCUMULATE) {
            generateActionCode(os, action, 2);
          }
        }
        // 嵌套条件（父条件是 SIGNAL_FALSE）
        for (const auto &nested : branch.nestedBranches) {
          generateConditionCode(os, nested, 2, ConditionType::SIGNAL_FALSE);
        }
      }
    }

    os << "    }\n";
  } else {
    // 非控制信号，使用原来的逻辑
    for (const auto &branch : handler.branches) {
      generateConditionCode(os, branch, 1);
    }
  }

  os << "}\n\n";
}

/// 检查信号是否是 ptimer 计数器
bool QEMUDeviceGenerator::isCounterSignal(llvm::StringRef name) const {
  for (const auto &sig : signals_) {
    if (sig.name == name && sig.type == QEMUSignalType::ICOUNT_COUNTER) {
      return true;
    }
  }
  return false;
}

/// 检查信号是否存在于状态结构体中（signals_ 或 inputSignals_）
bool QEMUDeviceGenerator::signalExists(llvm::StringRef name) const {
  // 检查是否在 signals_ 中
  for (const auto &sig : signals_) {
    if (sig.name == name) {
      return true;
    }
  }
  // 检查是否在 inputSignals_ 中
  for (const auto &input : inputSignals_) {
    if (input.first == name) {
      return true;
    }
  }
  // 检查是否是派生信号
  if (getDerivedSignal(name)) {
    return true;
  }
  return false;
}

/// 检查信号是否是派生信号
const clk_analysis::DerivedSignal* QEMUDeviceGenerator::getDerivedSignal(llvm::StringRef name) const {
  for (const auto &derived : derivedSignals_) {
    if (derived.name == name) {
      return &derived;
    }
  }
  return nullptr;
}

/// 生成信号读取表达式（对 ptimer 计数器和派生信号使用 get_ 函数）
std::string QEMUDeviceGenerator::getSignalReadExpr(llvm::StringRef name) const {
  std::string safeName = sanitizeName(name);
  if (isCounterSignal(name)) {
    return deviceName_ + "_get_" + safeName + "(s)";
  }
  // 检查是否是派生信号
  if (getDerivedSignal(name)) {
    return deviceName_ + "_get_" + safeName + "(s)";
  }
  return "s->" + safeName;
}

/// 获取控制信号控制的计数器列表
std::vector<std::string> QEMUDeviceGenerator::getControlledCounters(
    llvm::StringRef controlSignal, bool activeHigh) const {
  std::vector<std::string> result;
  for (const auto &rel : controlRelations_) {
    if (rel.controlSignal == controlSignal && rel.activeHigh == activeHigh) {
      result.push_back(rel.counterSignal);
    }
  }
  return result;
}

/// 生成 ptimer 启停代码
void QEMUDeviceGenerator::generatePtimerStartStop(llvm::raw_ostream &os,
                                                   llvm::StringRef counterName,
                                                   bool start, int indentLevel) {
  std::string safeName = sanitizeName(counterName);
  indent(os, indentLevel);
  if (start) {
    os << deviceName_ << "_start_" << safeName << "(s);  "
       << "/* 启动 ptimer */\n";
  } else {
    os << deviceName_ << "_stop_" << safeName << "(s);  "
       << "/* 停止 ptimer */\n";
  }
}

void QEMUDeviceGenerator::generateConditionCode(llvm::raw_ostream &os,
                                                 const clk_analysis::ConditionalBranch &branch,
                                                 int indentLevel,
                                                 clk_analysis::ConditionType parentCondType) {
  using namespace clk_analysis;

  // 检查是否与父条件重复（消除冗余条件）
  bool isRedundant = (branch.condType == parentCondType &&
                      (branch.condType == ConditionType::SIGNAL_TRUE ||
                       branch.condType == ConditionType::SIGNAL_FALSE));

  // 如果不是冗余条件，生成条件语句
  if (!isRedundant) {
    indent(os, indentLevel);
    switch (branch.condType) {
      case ConditionType::SIGNAL_TRUE:
        os << "if (value) {\n";
        break;
      case ConditionType::SIGNAL_FALSE:
        os << "if (!value) {\n";
        break;
      case ConditionType::COMPARE_GE:
        os << "if (" << getSignalReadExpr(branch.condSignal) << " >= "
           << getSignalReadExpr(branch.compareSignal) << ") {\n";
        break;
      case ConditionType::COMPARE_LT:
        os << "if (" << getSignalReadExpr(branch.condSignal) << " < "
           << getSignalReadExpr(branch.compareSignal) << ") {\n";
        break;
      case ConditionType::COMPARE_EQ:
        os << "if (" << getSignalReadExpr(branch.condSignal) << " == "
           << getSignalReadExpr(branch.compareSignal) << ") {\n";
        break;
      default:
        os << "/* unconditional */ {\n";
    }
  }

  // 计算嵌套的缩进级别
  int nestedIndent = isRedundant ? indentLevel : indentLevel + 1;

  // 生成动作
  for (const auto &action : branch.actions) {
    generateActionCode(os, action, nestedIndent);
  }

  // 生成嵌套条件分支（传递当前条件类型以检测冗余）
  for (const auto &nestedBranch : branch.nestedBranches) {
    generateConditionCode(os, nestedBranch, nestedIndent, branch.condType);
  }

  // 如果不是冗余条件，关闭大括号
  if (!isRedundant) {
    indent(os, indentLevel);
    os << "}\n";
  }
}

void QEMUDeviceGenerator::generateActionCode(llvm::raw_ostream &os,
                                              const clk_analysis::EventAction &action,
                                              int indentLevel) {
  using namespace clk_analysis;

  indent(os, indentLevel);

  std::string safeTarget = sanitizeName(action.targetSignal);
  std::string safeSource = sanitizeName(action.sourceSignal);

  // 检查目标是否是 icount 计数器
  bool isCounter = false;
  for (const auto &sig : signals_) {
    if (sig.name == action.targetSignal &&
        sig.type == QEMUSignalType::ICOUNT_COUNTER) {
      isCounter = true;
      break;
    }
  }

  switch (action.type) {
    case ActionType::ASSIGN_CONST: {
      // 处理布尔值：-1 表示 true (全1), 0 表示 false
      int64_t value = action.constValue;
      if (value == -1) value = 1;  // true

      if (isCounter) {
        os << deviceName_ << "_set_" << safeTarget
           << "(s, " << value << ");\n";
      } else {
        os << "s->" << safeTarget << " = " << value << ";\n";
      }
      break;
    }

    case ActionType::ASSIGN_SIGNAL:
      // 验证源信号是否存在于状态结构体中
      if (!signalExists(action.sourceSignal)) {
        os << "/* undefined signal: " << action.sourceSignal << " */\n";
        break;
      }
      if (isCounter) {
        os << deviceName_ << "_set_" << safeTarget
           << "(s, s->" << safeSource << ");\n";
      } else {
        os << "s->" << safeTarget << " = s->" << safeSource << ";\n";
      }
      break;

    case ActionType::ACCUMULATE:
      if (isCounter) {
        os << "/* counter accumulate handled by ptimer */\n";
      } else {
        os << "s->" << safeTarget << " += " << action.constValue << ";\n";
      }
      break;

    case ActionType::ASSIGN_COMPARE: {
      // 生成比较表达式: signal = (lhs cmp rhs)
      std::string lhsExpr = getSignalReadExpr(action.compareLhs);
      std::string rhsExpr = getSignalReadExpr(action.compareRhs);
      const char* cmpOp = "==";
      switch (action.compareType) {
        case clk_analysis::CompareType::GE: cmpOp = ">="; break;
        case clk_analysis::CompareType::LT: cmpOp = "<"; break;
        case clk_analysis::CompareType::EQ: cmpOp = "=="; break;
        case clk_analysis::CompareType::NE: cmpOp = "!="; break;
        default: break;
      }
      os << "s->" << safeTarget << " = ("
         << lhsExpr << " " << cmpOp << " " << rhsExpr << ");\n";
      break;
    }

    case ActionType::COMPUTE: {
      // 表达式格式: "targetSignal = expr"
      // 需要添加 s-> 前缀和分号
      std::string expr = action.expression;
      size_t eqPos = expr.find(" = ");
      if (eqPos != std::string::npos) {
        std::string target = expr.substr(0, eqPos);
        std::string rhs = expr.substr(eqPos + 3);  // 跳过 " = "
        std::string safeTarget = sanitizeName(target);
        os << "s->" << safeTarget << " = " << rhs << ";\n";
      } else {
        // 如果没有赋值，可能是纯表达式或注释
        os << expr << "\n";
      }
      break;
    }
  }
}

const char* QEMUDeviceGenerator::getCType(int bitWidth) {
  if (bitWidth <= 8) return "uint8_t";
  if (bitWidth <= 16) return "uint16_t";
  if (bitWidth <= 32) return "uint32_t";
  return "uint64_t";
}

std::string QEMUDeviceGenerator::toUpperCase(llvm::StringRef s) {
  std::string result = s.str();
  for (char &c : result) {
    c = std::toupper(static_cast<unsigned char>(c));
  }
  return result;
}

std::string QEMUDeviceGenerator::sanitizeName(llvm::StringRef name) {
  std::string result = name.str();
  for (char &c : result) {
    if (c == '.' || c == '[' || c == ']' || c == '-' || c == ' ') {
      c = '_';
    }
  }
  // 确保不以数字开头
  if (!result.empty() && std::isdigit(static_cast<unsigned char>(result[0]))) {
    result = "_" + result;
  }
  return result;
}

} // namespace qemu_codegen
